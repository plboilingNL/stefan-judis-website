#!/usr/bin/env node

require('dotenv').config();
const contentful = require('contentful');
const sqip = require('sqip');
const download = require('download');
const sizeOf = require('image-size');
const pLimit = require('p-limit');
const { join } = require('path');
const { emptyDir, writeFile, readFile } = require('fs-extra');
const { logSeparator, logSuccess } = require('./utils');

const limit = pLimit(8);

const { CTF_SPACE_ID, CTF_CDA_TOKEN } = process.env;
const client = contentful.createClient({
  accessToken: CTF_CDA_TOKEN,
  host: 'cdn.contentful.com',
  space: CTF_SPACE_ID,
});

const { getCachePath, shouldClearCache } = require('./utils/index.js');
const SQIP_CACHE = getCachePath('sqip');
const ELEVENTY_DATA_DIR = join(__dirname, '..', 'site', '_data');

async function sqipItems() {
  if (shouldClearCache) {
    logSeparator(`Clearing ${SQIP_CACHE}`);
    await emptyDir(SQIP_CACHE);
    logSuccess('SQIP cached deleted');
  }

  logSeparator('Getting asset information');

  const { items } = await client.getAssets({ limit: 1000 });
  let images = items
    .filter(
      ({ fields }) =>
        fields.file &&
        ['image/png', 'image/jpeg'].indexOf(fields.file.contentType) !== -1
    )
    .map(({ sys, fields }) => ({
      id: sys.id,
      revision: sys.revision,
      url: fields.file.url,
      filename: `${sys.id}-${sys.revision}.${
        fields.file.contentType.split('/')[1]
      }`,
      svg: null,
    }));

  logSuccess('Asset information queried');
  logSeparator(`Reading cached SVGs from at ${SQIP_CACHE}`);

  images = await Promise.all(
    images.map(async (image) => {
      try {
        const svg = await readFile(
          `${SQIP_CACHE}/${image.id}-${image.revision}.svg`,
          'utf8'
        );
        if (svg.startsWith('<svg')) {
          image.svg = svg;
        }
      } catch (e) {}

      return image;
    })
  );

  logSuccess('Cached SVGs read');
  logSeparator('Downloading images for missing SVGs');

  await Promise.all(
    images.map(({ url, filename, svg }) => {
      return limit(() => {
        if (!svg) {
          console.log(`${filename} is missing -> downloading`);
          return download(url.replace(/\/\//, 'https://'), SQIP_CACHE, {
            filename,
          });
        }

        return Promise.resolve();
      });
    })
  );

  logSuccess('Images downloaded');
  logSeparator('Creating missing SVGs');

  await Promise.all(
    images.map(({ id, revision, filename, svg }) => {
      if (!svg) {
        console.log(`SVG for ${filename} is missing -> sqipping`);
        const { final_svg } = sqip({
          filename: join(SQIP_CACHE, filename),
          numberOfPrimitives: 8,
          mode: 0,
          blur: 0,
        });

        return writeFile(join(SQIP_CACHE, `${id}-${revision}.svg`), final_svg);
      }

      return Promise.resolve();
    })
  );

  logSuccess('SVGs created');
  logSeparator('Reading image details (width/height)');

  images.forEach((image) => {
    const { id, revision, filename } = image;
    const detailsPath = join(SQIP_CACHE, `${id}-${revision}-details.json`);

    try {
      image.details = require(detailsPath);
    } catch (error) {
      const { height, width } = sizeOf(join(SQIP_CACHE, filename));
      const details = {
        height,
        width,
        ratio: Math.floor((height / width) * 10000) / 100,
      };
      writeFile(detailsPath, JSON.stringify(details));
      image.details = details;
    }
  });

  logSuccess('Read / created detail json files');
  logSeparator('Writing SVG JSON');

  const SQIP_JSON_FILE = join(ELEVENTY_DATA_DIR, '_sqip.json');
  await writeFile(
    SQIP_JSON_FILE,
    JSON.stringify(
      images.reduce((acc, { id, details, filename, svg }) => {
        acc[id] = {
          filename,
          details,
          svg,
        };
        return acc;
      }, {}),
      null,
      2
    )
  );
  logSuccess(`Wrote ${SQIP_JSON_FILE}`);
}

sqipItems();
